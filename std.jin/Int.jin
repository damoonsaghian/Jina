;c3 import std::math

;; https://flintlib.org/doc/fmpz.html
Int :=
;ns Int ::Ring ::Ord ::CharRep

;c3 typedef IntS = isz;

;ns IntS ::math.StructRing ::math.StructOrd ::CharRep
	to'Int64 = { self -> Int64 |
		;c3 return (Int64) (long) (isz) self;
	}
	to'Int = { self -> Int |
		;c3 return ;
	}
	to'Float = { self -> Float |
		;c3 return ;
	}
	to'Complex[IntS] = { self -> Complex[IntS] |
		math.Complex[IntS] self 0
	}
	to'math'Complex[Int64] = { self -> math.Complex[Int64] |
		math.Complex[Int64] self 0
	}
	to'math'Complex[Int] = { self -> math.Complex[Int] |
		math.Complex[Int] self 0
	}
	to'math'Complex[Float] = { self -> math.Complex[Float] |
		math.Complex[Float] self 0
	}
	
	add'op = {
		self, addend :Int -> Int |
			;c3 return self + addend;
		self, addend :Int64 -> Int64 |
			;c3 return self + addend;
		self, addend :Float -> Float |
			;c3 return self + addend;
		self, addend :Float32 -> Float32 |
			;c3 return self + addend;
		self, addend :math.Num -> math.Num |
			addend + self
		self, addend :math.NumI -> math.NumI |
			addend + self
	}
	
	add = {
		self!, addend :Int |
			;c3 self += addend;
		self!, addend :Int32 |
			;c3 self += addend;
		self!, addend :Int16 |
			;c3 self += addend;
		self!, addend :Int8 |
			;c3 self += addend;
	}
	
	sub'op = {
		self, subtrahend :Int -> Int |
			;c3 return self - subtrahend;
		self, subtrahend :Int32 -> Int |
			;c3 return self - subtrahend;
		self, subtrahend :Int16 -> Int |
			;c3 return self - subtrahend;
		self, subtrahend :Int8 -> Int |
			;c3 return self - subtrahend;
		self, subtrahend :Int64 -> Int64 |
			;c3 return self - subtrahend;
		self, subtrahend :Float -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Float32 -> Float32 |
			;c3 return self - subtrahend;
	}
	
	sub = {
		self!, subtrahend :Int |
			;c3 self -= subtrahend;
		self!, subtrahend :Int32 |
			;c3 self -= subtrahend;
		self!, subtrahend :Int16 |
			;c3 self -= subtrahend;
		self!, subtrahend :Int8 |
			;c3 self -= subtrahend;
	}
	
	mul'op = {
		self, multiplicand :Int -> Int |
			;c3 return self * multiplicand;
		self, multiplicand :Int32 -> Int |
			;c3 return self * multiplicand;
		self, multiplicand :Int16 -> Int |
			;c3 return self * multiplicand;
		self, multiplicand :Int8 -> Int |
			;c3 return self * multiplicand;
		self, multiplicand :Int64 -> Int64 |
			;c3 return self * multiplicand;
		self, multiplicand :Float -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Float32 -> Float32 |
			;c3 return self * multiplicand;
	}
	
	mul = {
		self!, multiplicand :Int |
			;c3 self *= multiplicand;
		self!, multiplicand :Int32 |
			;c3 self *= multiplicand;
		self!, multiplicand :Int16 |
			;c3 self *= multiplicand;
		self!, multiplicand :Int8 |
			;c3 self *= multiplicand;
	}
	
	div'op = {
		self, divisor :Int -> ?Int |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Int32 -> ?Int |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Int16 -> ?Int |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Int8 -> ?Int |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Int64 -> ?Int64 |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Float -> ?Float |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Float32 -> ?Float32 |
			;c3 if (x != 0) return self / divisor;
			#null
	}
	
	div = {
		self!, divisor :Int -> Bool |
			;c3 if (x != 0) { self /= divisor; return true; }
			#false
		self!, divisor :Int32 -> Bool |
			;c3 if (x != 0) { self /= divisor; return true; }
			#false
		self!, divisor :Int16t -> Bool|
			;c3 if (x != 0) { self /= divisor; return true; }
			#false
		self!, divisor :Int8 -> Bool |
			;c3 if (x != 0) { self /= divisor; return true; }
			#false
	}
	
	mod'op = {
		self, devisor :Int -> ?Int |
			;c3 if (x != 0) return self % divisor;
			#null
		self, devisor :Int32 -> ?Int |
			;c3 if (x != 0) return self % divisor;
			#null
		self, devisor :Int16 -> ?Int |
			;c3 if (x != 0) return self % divisor;
			#null
		self, devisor :Int8 -> ?Int |
			;c3 if (x != 0) return self % divisor;
			#null
		self, devisor :Int64 -> ?Int64 |
			;c3 if (x != 0) return self % divisor;
			#null
	}
	
	mod = {
		self, devisor :Int -> Bool |
			;c3 if (x != 0) { self %= divisor; return true; }
			#false
		self, devisor :Int32 -> Bool |
			;c3 if (x != 0) { self %= divisor; return true; };
			#false
		self, devisor :Int16 -> Bool |
			;c3 if (x != 0) { self %= divisor; return true; };
			#false
		self, devisor :Int8 -> Bool |
			;c3 if (x != 0) { self %= divisor; return true; };
			#false
	}
	
	neg'op = { self -> Int |
		;c3 return -self;
	}
	
	neg = { self! |
		;c3 self *= -1;
	}
	
	abs = { self -> Int |
		;c3 math.abs(self);
	}
	
	to'intu = { self -> IntU |
		;c3 return (IntU) (uint) (isz) self;
	}
	to'int32 = { self -> Int32 |
		;c3 return (Int32) (int) (isz) self;
	}
	
	min = ;c3
	max = ;c3
	
	;; create a range iterator
	til = { self, end :Int -> Iter[Int] |
	}
	
	;;math.StructOrd
	
	is'equal = { self, other :Int -> Bool |
		;c3 self == other;
	}
	
	is'after = { self, other :Int -> Bool |
		;c3 self > other;
	}
	
	;;CharRep
	to'chars = { self -> CharS |
	}

;c3 typedef IntU = usz;
;ns IntU ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int64 = long;
;ns Int64 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int32 = int;
;ns Int32 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU32 = uint;
;ns IntU32 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int16 = short;
;ns Int16 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU16 = ushort;
;ns IntU16 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int8 = ichar;
;ns Int8 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU8 = char;
;ns IntU8 ::math.StructRing ::math.StructOrd ::CharRep
