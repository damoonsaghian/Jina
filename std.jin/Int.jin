;c3 import std::math

;c3 typedef Int = isz;

;ns Int ::Num ::Ord ::StrRep
	to'Int64 = { self -> Int64 |
		;c3 return (Int64) (long) (isz) self;
	}
	to'IntA = { self -> IntA |
		;c3 return ;
	}
	to'NumA = { self -> NumA |
		;c3 return ;
	}
	to'Complex[t::Num] = { self -> Complex[t] |
		Complex[t] self 0
	}
	to'Tensor[t::Num] = { self -> Tensor[t] |
		Tensor[t] [self]
	}
	
	add'op = {
		self, addend :Int -> Int |
			;c3 return self + addend;
		self, addend :Int64 -> Int64 |
			;c3 return self + addend;
		self, addend :IntA -> IntA |
			;c3 return self + addend;
		self, addend :NumA -> NumA |
			;c3 return self + addend;
		self, addend :Complex[t::Num] -> Complex[t] |
			addend + self
		self, addend :Tensor[t::Num] -> Tensor[t] |
			addend + self
	}
	
	add = { self!, addend :Int |
		;c3 self += addend;
	}
	
	sub'op = {
		self, subtrahend :Int -> Int |
			;c3 return self - subtrahend;
		self, subtrahend :Int64 -> Int64 |
			;c3 return self - subtrahend;
		self, subtrahend :IntA -> IntA |
			;c3 return self - subtrahend;
		self, subtrahend :NumA -> NumA |
			;c3 return self - subtrahend;
		self, subtrahend :Complex[t::Num] -> Complex[t] |
			-subtrahend + self
		self, subtrahend :Tensor[t::Num] -> Tensor[t] |
			-subtrahend + self
	}
	
	sub = { self!, subtrahend :Int |
		;c3 self -= subtrahend;
	}
	
	mul'op = {
		self, multiplicand :Int -> Int |
			;c3 return self * multiplicand;
		self, multiplicand :Int64 -> Int64 |
			;c3 return self * multiplicand;
		self, multiplicand :IntA -> IntA |
			;c3 return self * multiplicand;
		self, multiplicand :NumA -> NumA |
			;c3 return self * multiplicand;
		self, multiplicand :Complex[t::Num] -> Complex[t] |
			multiplicand * self
		self, multiplicand :Tensor[t::Num] -> Tensor[t] |
			multiplicand * self
	}
	
	mul = { self!, multiplicand :Int |
		;c3 self *= multiplicand;
	}
	
	div'op = {
		self, divisor :Int -> ?Int |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Int64 -> ?Int64 |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :IntA -> ?IntA |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :NumA -> ?NumA |
			;c3 if (x != 0) return self / divisor;
			#null
		self, divisor :Complex[t] -> ?Complex[t] |
			divisor == 0 .then { #null } else: { (1+0i) * self / divisor }
		self, divisor :Tensor[t] -> ?Tensor[t] |
			divisor == 0 .then { #null } else: { Tensor[t] [1] * self / divisor }
	}
	
	div = { self!, divisor :Int -> Bool |
		;c3 if (x != 0) { self /= divisor; return true; }
		#false
	}
	
	mod'op = {
		self, modulus :Int -> ?Int |
			;c3 if (x != 0) return self % divisor;
			#null
		self, modulus :Int64 -> ?Int64 |
			;c3 if (x != 0) return self % divisor;
			#null
		self, modulus :IntA -> ?IntA |
			;c3 if (x != 0) return self % divisor;
			#null
	}
	
	mod = { self, devisor :Int -> Bool |
		;c3 if (x != 0) { self %= divisor; return true; }
		#false
	}
	
	neg'op = { self -> Int |
		;c3 return -self;
	}
	
	neg = { self! |
		;c3 self *= -1;
	}
	
	abs = { self -> Int |
		;c3 math.abs(self);
	}
	
	to'intu = { self -> IntU |
		;c3 return (IntU) (uint) (isz) self;
	}
	to'int32 = { self -> Int32 |
		;c3 return (Int32) (int) (isz) self;
	}
	to'float = { self -> Float2 |
	}
	
	min = ;c3
	max = ;c3
	
	;; create a range iterator
	til = { self, end :Int -> Iter[Int] |
	}
	
	;;math.StructOrd
	
	is'equal = { self, other :Int -> Bool |
		;c3 self == other;
	}
	
	is'after = { self, other :Int -> Bool |
		;c3 self > other;
	}
	
	;;CharRep
	to'chars = { self -> CharS |
	}

;c3 typedef IntU = usz;
;ns IntU ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int64 = long;
;ns Int64 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int32 = int;
;ns Int32 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU32 = uint;
;ns IntU32 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int16 = short;
;ns Int16 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU16 = ushort;
;ns IntU16 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef Int8 = ichar;
;ns Int8 ::math.StructRing ::math.StructOrd ::CharRep

;c3 typedef IntU8 = char;
;ns IntU8 ::math.StructRing ::math.StructOrd ::CharRep

;; https://gmplib.org/manual/
;; https://flintlib.org/doc/fmpz.html
IntA :=
;ns IntA ::Num ::Ord ::StrRep
