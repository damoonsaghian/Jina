;c3 import std::math

;; https://gmplib.org/manual/
;; https://flintlib.org/doc/fmpz.html
Int :=
;ns Int ::Num ::Ord ::StrRep
	to'Float = {}
	to'Complex[n::Num] = {}
	to'Tensor[n::Num] = {}

;c3 typedef Int8 = long;

;ns Int8 ::Num ::Ord ::StrRep
	to'Int = { self -> Int |
		;c3 return ;
	}
	to'Float = { self -> Float |
		;c3 return ;
	}
	to'Complex[n::Num] = { self -> Complex[n] |
		Complex[n] self 0
	}
	to'Tensor[n::Num] = { self -> Tensor[n] |
		Tensor[n] [self]
	}
	
	plus = { self, addend :Int8 -> Int8 |
		;c3 return self + addend;
	}
	plus = { self, addend :Int& -> Int |
		self.to'Int + addend
	}
	plus = { self, addend :Float& -> Float |
		self.to'Float + addend
	}
	plus[n::Num] = { self, addend :Complex[n] -> Complex[n] |
		self.to'Complex[n] + addend
	}
	plus[n::Num] = { self, addend :Tensor[n] -> Tensor[n] |
		self.to'Tensor[n] + addend
	}
	
	add = { self!, addend :Int8 |
		;c3 self += addend;
	}
	
	minus = { self, subtrahend :Int8 -> Int8 |
		;c3 return self - subtrahend;
	}
	minus = { self, subtrahend :Int& -> Int |
		self.to'Int - subtrahend
	}
	minus = { self, subtrahend :Float& -> Float |
		self.to'Float - subtrahend
	}
	minus[n::Num] = { self, subtrahend :Complex[n] -> Complex[n] |
		self.to'Complex[n] - subtrahend
	}
	minus[n::Num] = { self, subtrahend :Tensor[n] -> Tensor[n] |
		self.to'Tensor[n] - subtrahend
	}
	
	sub = { self!, subtrahend :Int8 -> Int8 |
		;c3 self -= subtrahend;
	}
	
	times = { self, multiplicand :Int8 -> Int8 |
		;c3 return self * multiplicand;
	}
	times = { self, multiplicand :Int& -> Int |
		self.to'Int * multiplicand
	}
	times = { self, multiplicand :Float& -> Float |
		self.to'Float * multiplicand
	}
	times[n::Num] = { self, multiplicand :Complex[n] -> Complex[n] |
		self.to'Complex[n] * multiplicand
	}
	times[n::Num] = { self, multiplicand :Tensor[n] -> Tensor[n] |
		self.to'Tensor[n] * multiplicand
	}
	
	mul = { self!, multiplicand :Int8 |
		;c3 self *= multiplicand;
	}
	
	over = { self, divisor :Int8 -> ?Int8 |
		;c3 if (divisor != 0) return self / divisor;
		#null
	}
	over = { self, divisor :Int -> ?Int |
		divisor == 0 .then { #null } .else { self.to'Int / divisor }
	}
	over = { self, divisor :Float -> ?Float |
		divisor == 0 .then { #null } .else { self.to'Num / divisor }
	}
	over[n::Num] = { self, divisor :Complex[t] -> ?Complex[n] |
		divisor.0 == 0 .then { #null } .else { self.to'Complex[n] / divisor }
	}
	over[n::Num] = { self, divisor :Tensor[t] -> ?Tensor[n] |
		divisor_0 == 0 .then { #null } .else { self.to'Tensor[n] / divisor }
	}
	
	div = { self!, divisor :Int8 -> Bool |
		divisor == 0 .then { #false } .else {
			;c3 self /= divisor
			#true
		}
	}
	
	mod'op = { self, modulus :Int8 -> ?Int8 |
		;c3 if (x != 0) return self % modulus;
		#null
	}
	mod'op = { self, modulus :Int -> ?Int |
		modulus == 0 .then { #null } .else { self.to'Int % modulus }
	}
	
	mod = { self, modulus :Int8 -> Bool |
		modulus == 0 .then { #false } .else {
			;c3 self %= divisor
			#true
		}
	}
	
	exp = {}
	
	log = {}
	
	neg = { self -> Int8 |
		;c3 return -self;
	}
	
	negate = { self! |
		;c3 self *= -1;
	}
	
	abs = { self -> Int8 |
		;c3 return math.abs(self);
	}
	
	min = ;c3
	max = ;c3
	
	;; create a range iterator
	til = { self, end :Int8 -> Iter[Int8] |
	}
	
	;;Ord
	
	is'equal = { self, other :Int8 -> Bool |
		;c3 self == other;
	}
	
	is'after = { self, other :Int8 -> Bool |
		;c3 self > other;
	}
	
	;;StrRep
	to'str = { self -> Str |
	}

;c3 typedef Int4 = int;
;ns Int4 ::Num ::Ord ::StrRep

;c3 typedef Int2 = short;
;ns Int2 ::Num ::Ord ::StrRep

;c3 typedef Int1 = ichar;
;ns Int1 ::Num ::Ord ::StrRep

;c3 typedef NumU = usz;
;ns NumU ::Num ::Ord ::StrRep

;c3 typedef NumU2 = ushort;
;ns NumU2 ::Num ::Ord ::StrRep

;c3 typedef NumU1 = char;
;ns NumU1 ::Num ::Ord ::StrRep
