;c3 import std::math

;tr Num

;c3 typedef Num = float;

;ns Num ::Num ::OrdP ::CharRep
	to'Float2 = { self -> Float2 |
		;c3 return (double) self
	}
	to'Complex[t] = { self -> Complex[t] |
		Complex[t] self 0
	}
	
	toIntA = { self -> math.NumI |
		;c3 return ;
	}
	
	to'Int = { self -> Int |
		;c3 return ;
	}
	to'IntU = { self -> IntU |
		;c3 return ;
	}
	to'Int64 = { self -> Int64 |
		;c3 return ;
	}
	to'Int32 = { self -> Int32 |
		;c3 return ;
	}
	to'IntU32 = { self -> IntU32 |
		;c3 return ;
	}
	to'Int16 = { self -> Int16 |
		;c3 return ;
	}
	to'IntU16 = { self -> IntU16 |
		;c3 return ;
	}
	to'Int8 = { self -> Int8 |
		;c3 return ;
	}
	to'IntU8 = { self -> IntU8 |
		;c3 return ;
	}
	
	add'op = {
		self&, addend :Num& -> Num |
		self&, addend :NumI& -> Num |
		self&, addend :Int -> Num |
		self&, addend :Int64 -> Num |
		self&, addend :Int32 -> Num |
		self&, addend :Int16 -> Num |
		self&, addend :Int8 -> Num |
		self&, addend :Float -> Num |
		self&, addend :Float32 -> Num |
	}
	
	add = {
		self!, addend :Num& |
		self!, addend :NumI& |
		self!, addend :Int |
		self!, addend :Int64 |
		self!, addend :Int32 |
		self!, addend :Int16 |
		self!, addend :Int8 |
		self!, addend :Float |
		self!, addend :Float32 |
	}
	
	sub'op = {
		self&, subtrahend :NuM& -> Num |
		self&, subtrahend :NumI& -> Num |
		self&, subtrahend :Int -> Num |
		self&, subtrahend :Int64 -> Num |
		self&, subtrahend :Int32 -> Num |
		self&, subtrahend :Int16 -> Num |
		self&, subtrahend :Int8 -> Num |
		self&, subtrahend :Float -> Num |
		self&, subtrahend :Float32 -> Num |
	}
	
	sub = {
		self!, subtrahend :Num& |
		self!, subtrahend :NumI& |
		self!, subtrahend :Int |
		self!, subtrahend :Int64 |
		self!, subtrahend :Int32 |
		self!, subtrahend :Int16 |
		self!, subtrahend :Int8 |
		self!, subtrahend :Float |
		self!, subtrahend :Float32 |
	}
	
	mul'op = {
		self&, multiplicand :Num& -> Num |
		self&, multiplicand :NumI& -> Num |
		self&, multiplicand :Int -> Num |
		self&, multiplicand :Int64 -> Num |
		self&, multiplicand :Int32 -> Num |
		self&, multiplicand :Int16 -> Num |
		self&, multiplicand :Int8 -> Num |
		self&, multiplicand :Float -> Num |
		self&, multiplicand :Float32 -> Num |
	}
	
	mul = {
		self!, multiplicand :Num& |
		self!, multiplicand :NumI& |
		self!, multiplicand :Int |
		self!, multiplicand :Int64 |
		self!, multiplicand :Int32 |
		self!, multiplicand :Int16 |
		self!, multiplicand :Int8 |
		self!, multiplicand :Float |
		self!, multiplicand :Float32 |
	}
	
	div'op = {
		self&, divisor :Num& -> Num |
		self&, divisor :NumI& -> Num |
		self&, divisor :Int -> Num |
		self&, divisor :Int64 -> Num |
		self&, divisor :Int32 -> Num |
		self&, divisor :Int16 -> Num |
		self&, divisor :Int8 -> Num |
		self&, divisor :Float -> Num |
		self&, divisor :Float32 -> Num |
	}
	
	div = {
		self!, divisor :Num& |
		self!, divisor :NumI& |
		self!, divisor :Int |
		self!, divisor :Int64 |
		self!, divisor :Int32 |
		self!, divisor :Int16 |
		self!, divisor :Int8 |
		self!, divisor :Float |
		self!, divisor :Float32 |
	}
	
	exp = {
		self&, exponent :Num& -> Num |
		self&, exponent :NumI& -> Num |
		self&, exponent :Int -> Num |
		self&, exponent :Int64 -> Num |
		self&, exponent :Int32 -> Num |
		self&, exponent :Int16 -> Num |
		self&, exponent :Int8 -> Num |
		self&, exponent :Float -> Num |
		self&, exponent :Float32 -> Num |
	}
	
	neg'op = { self$ -> Num$ |
	}
	
	neg = { self! |
	}
	
	abs = { self$ -> Num$ |
	}
	
	cos = { self& -> Num |
	}
	acos = { self& -> Num |
	}
	cosh = { self& -> Num |
	}
	atanh = { self& -> Num |
	}
	sin = { self& -> Num |
	}
	asin = { self& -> Num |
	}
	sinh = { self& -> Num |
	}
	tan = { self& -> Num |
	}
	atan = { self& -> Num |
	}
	atan2 = { self& -> Num |
	}
	tanh = { self& -> Num |
	}
	
	log = { self& -> Num |
	}
	log2 = { self& -> Num |
	}
	log10 = { self& -> Num |
	}
	
	inf =
	
	;; base of the natural logarithm
	e =
	pi =
	
	;; OrdMaybe
	
	equal = { self&, other :Num& -> ?Bool |
	}
	
	after = { self&, other :Num& -> ?Bool |
	}
	
	;; CharRep
	to'chars = { self& -> CharS |
	}

;c3 typedef Float32 = float;

;ns Float32 ::math.StructRing ::math.StructOrd ::CharRep
	to'Float2 = { self -> Float2 |
		;c3 return (Float2) (double) self;
	}
	to'math'Num = { self -> math.Num |
		;c3 return ;
	}
	to'math'Complex[Float] = { self -> math.Complex[Float] |
		math.Complex[Float] self 0
	}
	to'math'Complex[Float2] = { self -> math.Complex[Float2] |
		math.Complex[Float2] self 0
	}
	to'math'Complex[Num] = { self -> math.Complex[Num] |
		math.Complex[Num] self 0
	}
	to'math'ComplexQ[Float] = { self -> math.ComplexQ[Float] |
		math.ComplexQ[Float] self 0
	}
	to'math'ComplexQ[Float2] = { self -> math.ComplexQ[Float2] |
		math.ComplexQ[Float2] self 0
	}
	to'math'ComplexQ[Num] = { self -> math.ComplexQ[Num] |
		math.ComplexQ[Num] self 0
	}
	to'math'ComplexO[Float] = { self -> math.ComplexO[Float] |
		math.ComplexO[Float] self 0
	}
	to'math'ComplexO[Float2] = { self -> math.ComplexO[Float2] |
		math.ComplexO[Float2] self 0
	}
	to'math'ComplexO[Num] = { self -> math.ComplexO[Num] |
		math.ComplexO[Num] self 0
	}
	to'math'Tensor[Float] = { self -> math.Tensor[Float] |
		math.Tensor[Float] self 0
	}
	to'math'Tensor[Float2] = { self -> math.Tensor[Float2] |
		math.Tensor[Float2] self 0
	}
	to'math'Tensor[Num] = { self -> math.Tensor[Num] |
		math.Tensor[Num] self 0
	}
	
	add'op = {
		self, addend :Float -> Float |
			;c3 return self + addend;
		self, addend :Float32 -> Float |
			;c3 return self + addend;
		self, addend :Int -> Float |
			;c3 return self + addend;
		self, addend :Int64 -> Float |
			;c3 return self + addend;
		self, addend :Int32 -> Float |
			;c3 return self + addend;
		self, addend :Int16 -> Float |
			;c3 return self + addend;
		self, addend :Int8 -> Float |
			;c3 return self + addend;
	}
	
	add = {
		self!, addend :Float |
			;c3 self += addend;
		self!, addend :Float32 |
			;c3 self += addend;
		self!, addend :Int |
			;c3 self += addend;
		self!, addend :Int64 |
			;c3 self += addend;
		self!, addend :Int32 |
			;c3 self += addend
		self!, addend :Int16 |
			;c3 self += addend;
		self!, addend :Int8 |
			;c3 self += addend;
	}
	
	sub'op = {
		self, subtrahend :Float -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Float32 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int64 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int32 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int16 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int8 -> Float |
			;c3 return self - subtrahend;
	}
	
	sub = {
		self!, subtrahend :Float |
			;c3 self -= subtrahend;
		self!, subtrahend :Float32 |
			;c3 self -= subtrahend;
		self!, subtrahend :Int |
			;c3 self -= subtrahend;
		self!, subtrahend :Int64 |
			;c3 self -= subtrahend;
		self!, subtrahend :Int32 |
			;c3 self -= subtrahend
		self!, subtrahend :Int16 |
			;c3 self -= subtrahend;
		self!, subtrahend :Int8 |
			;c3 self -= subtrahend;
	}
	
	mul'op = {
		self, multiplicand :Float -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Float32 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int64 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int32 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int16 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int8 -> Float |
			;c3 return self * multiplicand;
	}
	
	mul = {
		self!, multiplicand :Float |
			;c3 self *= multiplicand;
		self!, multiplicand :Float32 |
			;c3 self *= multiplicand;
		self!, multiplicand :Int |
			;c3 self *= multiplicand;
		self!, multiplicand :Int64 |
			;c3 self *= multiplicand;
		self!, multiplicand :Int32 |
			;c3 self *= multiplicand
		self!, multiplicand :Int16 |
			;c3 self *= multiplicand;
		self!, multiplicand :Int8 |
			;c3 self *= multiplicand;
	}
	
	div'op = {
		self, divisor :Float -> Float |
			;c3 return self / divisor;
		self, divisor :Float32 -> Float |
			;c3 return self / divisor;
		self, divisor :Int -> Float |
			;c3 return self / divisor;
		self, divisor :Int64 -> Float |
			;c3 return self / divisor;
		self, divisor :Int32 -> Float |
			;c3 return self / divisor;
		self, divisor :Int16 -> Float |
			;c3 return self / divisor;
		self, divisor :Int8 -> Float |
			;c3 return self / divisor;
	}
	
	div = {
		self!, divisor :Float |
			;c3 self /= divisor;
		self!, divisor :Float32 |
			;c3 self /= divisor;
		self!, divisor :Int |
			;c3 self /= divisor;
		self!, divisor :Int64 |
			;c3 self /= divisor;
		self!, divisor :Int32 |
			;c3 self /= divisor;
		self!, divisor :Int16 |
			;c3 self /= divisor;
		self!, divisor :Int8 |
			;c3 self /= divisor;
	}
	
	exp = {
		self, exponent :Float -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Float32 -> Float32 |
			;c3 return float.pow(self, exponent);
		self, exponent :Int -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int64 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int32 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int16 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int8 -> Float |
			;c3 return double.pow(self, exponent);
	}
	
	neg'op = { self -> Float |
		;c3 return -self;
	}
	
	neg = { self! |
		;c3 self *= -1;
	}
	
	abs = { self -> Float |
		;c3 return math.abs(self);
	}
	
	next'up = { self -> Float |
	}
	next'down = { self -> Float |
	}
	
	cos = { self -> Float |
	}
	acos = { self -> Float |
	}
	cosh = { self -> Float |
	}
	atanh = { self -> Float |
	}
	sin = { self -> Float |
	}
	asin = { self -> Float |
	}
	sinh = { self -> Float |
	}
	tan = { self -> Float |
	}
	atan = { self -> Float |
	}
	atan2 = { self -> Float |
	}
	tanh = { self -> Float |
	}
	
	log = { self -> Float |
	}
	log2 = { self -> Float |
	}
	log10 = { self -> Float |
	}
	
	to'int = { self, direction :(#up #down) = #down -> Int |
		;c3 return (Int) (isz) (float) self;
	}
	
	nan = ;c3
	inf = ;c3
	
	;; base of the natural logarithm
	e = ;c3
	
	pi = ;c3
	
	;;math.StructOrd
	
	equal = { self, other :Float -> Bool |
		;c3 self == other;
	}
	
	after = { self, other :Float -> Bool |
		;c3 self > other;
	}
	
	;;CharRep
	to'chars = { self -> CharS |
	}

;c3 typedef Float2 = double;
;ns Float2 ::Num ::Ord ::CharRep

;; https://flintlib.org/doc/arb.html
;; stored as decimal
NumA :=
