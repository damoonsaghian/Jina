;c3 import std::math

;tr Num

;c3 typedef Num = float;

;ns Num ::Num ::Ord ::StrRep
	to'Num2 = { self -> Num2 |
		;c3 return (Num2) (double) self;
	}
	to'NumA = { self -> NumA |
		;c3 return ;
	}
	to'Complex[n::Num] = { self -> Complex[n] |
		Complex[n] self 0
	}
	to'Tensor[t::Num] = { self -> Tensor[t] |
		Tensor[t] [self]
	}
	
	add'op = {
		self, addend :Num -> Num |
			;c3 return self + addend;
		self, addend :Num2 -> Num2 |
			;c3 return self + addend;
		self, addend :NumA -> NumA |
			;c3 return self + addend;
		self, addend :Complex[t::Num] -> Complex[t] |
			addend + self
		self, addend :Tensor[t::Num] -> Tensor[t] |
			addend + self
	}
	
	add = { self!, addend :Num |
		;c3 self += addend;
	}
	
	sub'op = {
		self, subtrahend :Float -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Float32 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int64 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int32 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int16 -> Float |
			;c3 return self - subtrahend;
		self, subtrahend :Int8 -> Float |
			;c3 return self - subtrahend;
	}
	
	sub = { self!, subtrahend :Num |
		;c3 self -= subtrahend;
	}
	
	mul'op = {
		self, multiplicand :Float -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Float32 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int64 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int32 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int16 -> Float |
			;c3 return self * multiplicand;
		self, multiplicand :Int8 -> Float |
			;c3 return self * multiplicand;
	}
	
	mul = { self!, multiplicand :Num |
		;c3 self *= multiplicand;
	}
	
	div'op = {
		self, divisor :Float -> Float |
			;c3 return self / divisor;
		self, divisor :Float32 -> Float |
			;c3 return self / divisor;
		self, divisor :Int -> Float |
			;c3 return self / divisor;
		self, divisor :Int64 -> Float |
			;c3 return self / divisor;
		self, divisor :Int32 -> Float |
			;c3 return self / divisor;
		self, divisor :Int16 -> Float |
			;c3 return self / divisor;
		self, divisor :Int8 -> Float |
			;c3 return self / divisor;
	}
	
	div = { self!, divisor :Float |
		;c3 self /= divisor;
	}
	
	exp = {
		self, exponent :Float -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Float32 -> Float32 |
			;c3 return float.pow(self, exponent);
		self, exponent :Int -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int64 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int32 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int16 -> Float |
			;c3 return double.pow(self, exponent);
		self, exponent :Int8 -> Float |
			;c3 return double.pow(self, exponent);
	}
	
	neg'op = { self -> Float |
		;c3 return -self;
	}
	
	neg = { self! |
		;c3 self *= -1;
	}
	
	abs = { self -> Num |
		;c3 return math.abs(self);
	}
	
	next'up = { self -> Float |
	}
	next'down = { self -> Float |
	}
	
	cos = { self -> Float |
	}
	acos = { self -> Float |
	}
	cosh = { self -> Float |
	}
	atanh = { self -> Float |
	}
	sin = { self -> Float |
	}
	asin = { self -> Float |
	}
	sinh = { self -> Float |
	}
	tan = { self -> Float |
	}
	atan = { self -> Float |
	}
	atan2 = { self -> Float |
	}
	tanh = { self -> Float |
	}
	
	log = { self -> Float |
	}
	log2 = { self -> Float |
	}
	log10 = { self -> Float |
	}
	
	to'int = { self, direction :(#up #down) = #down -> Int |
		;c3 return (Int) (isz) (float) self;
	}
	
	nan = ;c3
	inf = ;c3
	
	;; base of the natural logarithm
	e = ;c3
	
	pi = ;c3
	
	;;math.StructOrd
	
	equal = { self, other :Float -> Bool |
		;c3 self == other;
	}
	
	after = { self, other :Float -> Bool |
		;c3 self > other;
	}
	
	;;CharRep
	to'str = { self -> Str |
	}

;c3 typedef Num2 = double;
;ns Num2 ::Num ::Ord ::StrRep

;; https://flintlib.org/doc/arb.html
;; stored as decimal
;ns NumA ::Num ::OrdP ::StrRep
	to'Complex[t::Num] = { self -> Complex[t] |
		Complex[t] self 0
	}
	to'Tensor[t::Num] = { self -> Complex[t] |
		Complex[t] self 0
	}
	
	toIntA = { self -> math.NumI |
		;c3 return ;
	}
	
	to'Int = { self -> Int |
		;c3 return ;
	}
	to'IntU = { self -> IntU |
		;c3 return ;
	}
	to'Int64 = { self -> Int64 |
		;c3 return ;
	}
	to'Int32 = { self -> Int32 |
		;c3 return ;
	}
	to'IntU32 = { self -> IntU32 |
		;c3 return ;
	}
	to'Int16 = { self -> Int16 |
		;c3 return ;
	}
	to'IntU16 = { self -> IntU16 |
		;c3 return ;
	}
	to'Int8 = { self -> Int8 |
		;c3 return ;
	}
	to'IntU8 = { self -> IntU8 |
		;c3 return ;
	}
	
	add'op = {
		self&, addend :Num& -> Num |
		self&, addend :NumI& -> Num |
		self&, addend :Int -> Num |
		self&, addend :Int64 -> Num |
		self&, addend :Int32 -> Num |
		self&, addend :Int16 -> Num |
		self&, addend :Int8 -> Num |
		self&, addend :Float -> Num |
		self&, addend :Float32 -> Num |
	}
	
	add = {
		self!, addend :Num& |
		self!, addend :NumI& |
		self!, addend :Int |
		self!, addend :Int64 |
		self!, addend :Int32 |
		self!, addend :Int16 |
		self!, addend :Int8 |
		self!, addend :Float |
		self!, addend :Float32 |
	}
	
	sub'op = {
		self&, subtrahend :NuM& -> Num |
		self&, subtrahend :NumI& -> Num |
		self&, subtrahend :Int -> Num |
		self&, subtrahend :Int64 -> Num |
		self&, subtrahend :Int32 -> Num |
		self&, subtrahend :Int16 -> Num |
		self&, subtrahend :Int8 -> Num |
		self&, subtrahend :Float -> Num |
		self&, subtrahend :Float32 -> Num |
	}
	
	sub = {
		self!, subtrahend :Num& |
		self!, subtrahend :Num2 |
		self!, subtrahend :Float32 |
	}
	
	mul'op = {
		self&, multiplicand :Num& -> Num |
		self&, multiplicand :NumI& -> Num |
		self&, multiplicand :Int -> Num |
		self&, multiplicand :Int64 -> Num |
		self&, multiplicand :Int32 -> Num |
		self&, multiplicand :Int16 -> Num |
		self&, multiplicand :Int8 -> Num |
		self&, multiplicand :Float -> Num |
		self&, multiplicand :Float32 -> Num |
	}
	
	mul = {
		self!, multiplicand :Num& |
		self!, multiplicand :NumI& |
		self!, multiplicand :Int |
		self!, multiplicand :Int64 |
		self!, multiplicand :Int32 |
		self!, multiplicand :Int16 |
		self!, multiplicand :Int8 |
		self!, multiplicand :Float |
		self!, multiplicand :Float32 |
	}
	
	div'op = {
		self&, divisor :Num& -> Num |
		self&, divisor :NumI& -> Num |
		self&, divisor :Int -> Num |
		self&, divisor :Int64 -> Num |
		self&, divisor :Int32 -> Num |
		self&, divisor :Int16 -> Num |
		self&, divisor :Int8 -> Num |
		self&, divisor :Float -> Num |
		self&, divisor :Float32 -> Num |
	}
	
	div = {
		self!, divisor :Num& |
		self!, divisor :NumI& |
		self!, divisor :Int |
		self!, divisor :Int64 |
		self!, divisor :Int32 |
		self!, divisor :Int16 |
		self!, divisor :Int8 |
		self!, divisor :Float |
		self!, divisor :Float32 |
	}
	
	exp = {
		self&, exponent :Num& -> Num |
		self&, exponent :NumI& -> Num |
		self&, exponent :Int -> Num |
		self&, exponent :Int64 -> Num |
		self&, exponent :Int32 -> Num |
		self&, exponent :Int16 -> Num |
		self&, exponent :Int8 -> Num |
		self&, exponent :Float -> Num |
		self&, exponent :Float32 -> Num |
	}
	
	neg'op = { self$ -> Num$ |
	}
	
	neg = { self! |
	}
	
	abs = { self$ -> Num$ |
	}
	
	cos = { self& -> Num |
	}
	acos = { self& -> Num |
	}
	cosh = { self& -> Num |
	}
	atanh = { self& -> Num |
	}
	sin = { self& -> Num |
	}
	asin = { self& -> Num |
	}
	sinh = { self& -> Num |
	}
	tan = { self& -> Num |
	}
	atan = { self& -> Num |
	}
	atan2 = { self& -> Num |
	}
	tanh = { self& -> Num |
	}
	
	log = { self& -> Num |
	}
	log2 = { self& -> Num |
	}
	log10 = { self& -> Num |
	}
	
	inf =
	
	;; base of the natural logarithm
	e =
	pi =
	
	;; OrdMaybe
	
	equal = { self&, other :Num& -> ?Bool |
	}
	
	after = { self&, other :Num& -> ?Bool |
	}
	
	;; StrRep
	to'str = { self& -> Str |
	}
