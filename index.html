
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a programming language with sane memory management, actors, and a coherent syntax</div><div><p></p></div><div>Mahsa Jina Amini was a 22 years old girl, murdered by the evil Islamic regime in Iran</div><div>at her funeral, these words were written on a stone above her grave:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>memory management is done in a sane way, using type tags:</div><div>, plain type: T</div><div>, mutable borrow type: !T</div><div>, immutable borrow type: &T</div><div>, shared type: $T</div><div><p></p></div><div>plain type values will be copied, or moved if not used any more in the following code</div><div>	and at the end of the function, if they are not moved out, their memory will be deallocated</div><div>type tags alter this behavior</div><div>borrow types allow access by reference, but since the value is not moved into them,</div><div>	they don't intervene in the deallocation at the end of the function</div><div>	they can be returned from a function only if the primary lender is one of the function arguments</div><div>shared types allow access by reference, and they do run'time reference counting</div><div>	when the reference count reaches zero, their memory will be deallocated</div><div><p></p></div><div>plain type values can be put into:</div><div>, plain (copy/move)</div><div>, mutable borrow (borrow)</div><div>, immutable borrow (copy stack, borrow heap)</div><div>, shared (move)</div><div>and by "put into" i mean:</div><div>, variable assignment</div><div>, field assignment</div><div>, captured in a closure</div><div><p></p></div><div>mutable borrow can be put into:</div><div>, mutable borrow (borrow)</div><div>, immutable borrow (copy stack, borrow heap)</div><div><p></p></div><div>immutable borrow can be put into:</div><div>, immutable borrow (copy stack, borrow heap)</div><div><p></p></div><div>shared own can be put into:</div><div>, immutable borrow (copy stack, borrow heap)</div><div>, shared own (copy stack, borrow heap)</div><div>	increments the reference counter</div><div><p></p></div><div>in Jina, shared mutability is only possible through unique own types</div><div>thus reference cycles are impossible</div><div><a href='https://doc.rust-lang.org/book/ch15-06-reference-cycles.html'>https://doc.rust-lang.org/book/ch15-06-reference-cycles.html</a></div><div><p></p></div><div>numbers are stored on the stack (thus don't need memory management)</div><div>small records will be kept on stack, big ones on the heap</div><div>lists and dictionaries can initially be stored on the stack, if they are small</div><div>	and when they grow they will be reallocated on the heap</div><div><p></p></div><div><a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div><p></p></div><div>actors are used to achieve lock'free concurrency</div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, there's no mechanism being used to synchronize access to the data</div><div><p></p></div><div>to deal with it, programming languages choose different approaches:</div><div>, abandon concurrency altogether; make single threaded programs</div><div>, implement complicated and error prone lock mechanisms</div><div>, abandon mutability like in pure functional programming; but since at the end, mutability is necessary,</div><div>	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used</div><div>	<a href='https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples'>https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples</a></div><div>	<a href='https://clojure-doc.org/articles/language/concurrency_and_parallelism/'>https://clojure-doc.org/articles/language/concurrency_and_parallelism/</a></div><div>	any how, the lack of direct mutability, and the need for aggressive garbage collection,</div><div>		means that functional programming is not an efficient method</div><div>, use the approach taken by Pony <a href='https://www.ponylang.io/'>https://www.ponylang.io/</a></div><div>	it controls aliasing (sharing) and mutability, using reference capabilities</div><div>	Pony's approach introduces many complexities, especially when dealing with generics</div><div><p></p></div><div>in Jina, all mutations are done inside actors and are thus are synchronous</div><div>messages sent to actors are shared own closures</div><div>and as described above, they can only capture unique own and shared own variables</div><div>thus messages can safely be called asynchronously, since they can't change their captured environment</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>inheritance is problematic:</div><div><a href='https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)'>https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></div><div><a href='https://www.tedinski.com/2018/06/26/variance.html'>https://www.tedinski.com/2018/06/26/variance.html</a></div><div>i feel that this problem was the motivation behind dynamic typing (another bad design)</div><div>to avoid this problem, some languages (eg Rust) have two kinds of types:</div><div>, concrete types can be instantiated, but cannot have subtypes</div><div>, abstract types cannot be instantiated, but can have subtypes</div><div>Jina does the same, without actually splitting types into two kinds</div><div><p></p></div><div>Jina compiles to C3, and thus can easily use existing C libraries</div><div><p></p></div><div>to install Jina in SPM Linux:</div><div>; spm install $gnunet_namespace jina</div><div>in other Unix'like systems, install "gnunet", then:</div><div>; gnunet-download -o spm/ gnunet://fs/sks/$gnunet_namespace/packages/spm</div><div>; sh spm/install.sh</div><div>; spm install $gnunet_namespace jina</div>
<h2>2, syntax</h2><div>comments:</div><div>	;; comment line</div><div>	;; comment</div><div>		block</div><div>	;;</div><div>	comment</div><div>	block</div><div>	;</div><div><p></p></div><div>identifiers (variable names) start with an alphabetic character, and can include numbers and apostrophe:</div><div>	abc'efg0123</div><div>template identifiers ("x" and "y" will be used in the definition of the variable):</div><div>	abc[x, y]</div><div><p></p></div><div>variable definition:</div><div>	v :T = ...</div><div>	v = ...</div><div>mutable borrow variable definition:</div><div>	v :!T = ...</div><div>	v !T = ...</div><div>	v! = ...</div><div>immutable ref type variable definition:</div><div>	v :&T = ...</div><div>	v &T = ...</div><div>	v& = ...</div><div>shared own variable definition:</div><div>	v :$T = ...</div><div>	v $T = ...</div><div>	v$ = ...</div><div><p></p></div><div>assignment to mutable variables:</div><div>	v. = ...</div><div><p></p></div><div>numeric types:</div><div>, Num: floating point with mid-rad interval arithmetics (or C3 "double" if --no-flint)</div><div>, Num'i: multi'precision integer (or C3 "isz" if --no-flint)</div><div>, Num'w: word sized unsigned integers; compiled to "usz" type in C3</div><div>, Num8: compiled to "char" type in C3</div><div>literal numbers:</div><div>	1.23e4 ;; Num</div><div>	1.0 ;; Num</div><div>	1'234'567'890 ;; Num'i</div><div>	0123 ;; Num'w</div><div>	0x1234'5678'9abc'def0 ;; Num'w (on 32 bits systems, this number will be stored as 0x9abc'def0)</div><div>	#a ;; Num8 (ASCII code for character "a")</div><div>	#\n ;; Num8 (ASCII code for character with escape code "\n")</div><div>	#x12 ;; Num8 (ASCII code for character with hex code 12)</div><div><p></p></div><div>lists:</div><div>	l :List[Num] = [1, 2, 3]</div><div>indexing:</div><div>	l_1</div><div>mutating lists:</div><div>	l.put 0 at: 0 ;; [0, 2, 3]</div><div>	l.put 4 at: 3 ;; [0, 2, 3, 4]</div><div>initial value of lists will be kept on stack</div><div>heap allocation is done only when the lists needs to grow beyond its initial size</div><div><p></p></div><div>strings are UTF8 encoded, and implemented using lists:</div><div>	s :String = "abc def"</div><div>as said for lists, double quotes creates a value with unique own type: !!String</div><div>string interpolation: "abc{x}"</div><div>it's better to split long strings into a list of single'line strings:</div><div>	"""</div><div>	first line</div><div>		second line</div><div>	"""</div><div>which is equivalent to:</div><div>	["first line", "\tsecond line"]</div><div><p></p></div><div>symbols are their own types:</div><div>	s :'s = 's</div><div><p></p></div><div>dictionaries are indexed using strings (instead of integers as in lists):</div><div>	d :Dict[Num] = [a: 1, b: 2, c: 3]</div><div>indexing:</div><div>	d_"a"</div><div><p></p></div><div>records:</div><div>	r :(a: Num, b: Num, c: Num) = a: 1, b: 2, c: 3</div><div>	r :(Num, Num, c: Num) = 1, 2, c: 3</div><div>to access elements:</div><div>	r.a</div><div>	r.0</div><div>multiple assignment using record expansion:</div><div>	a, b = 1, 2, 3</div><div>tagged fields can be expanded too, if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div>mutating a record (if "r" is a mutable variable):</div><div>	r.a = 10</div><div><p></p></div><div>function:</div><div>	f = { a :A, b &B -&gt; C | ... }</div><div>note that the type of above function is:</div><div>	(a: A, b: &B -&gt; C)</div><div>function call:</div><div>	f x y</div><div>which is equivalent to these forms:</div><div>	f(x, y)</div><div>	f b: y a: x</div><div>	(x, y) @ f</div><div><p></p></div><div>function with multiple match:</div><div>	f = {</div><div>	a :A |</div><div>		...</div><div>	b !B |</div><div>		...</div><div>	}</div><div><p></p></div><div>default values for parameters:</div><div>	f = { a = 1 , b = 2 | ... }</div><div>	f b: 22</div><div>	f 11</div><div>	f()</div><div><p></p></div><div>{f x y} can be written as: || f x y</div><div><p></p></div><div>conditional expression:</div><div>	condition.then {} else: {}</div><div>	condition1.then {} || condition2.then {} || condition3.then {} else: {}</div><div><p></p></div><div>and or:</div><div>	a && b</div><div>	a \\ b</div><div>which are equivalent to:</div><div>	a.and {b}</div><div>	a.or {b}</div><div>not: -a</div><div><p></p></div><div>there is no loop; just iterators:</div><div>	iter.each { x | ... }</div><div>any type that implements "Iter" interface, must define an "iter" method,</div><div>	whose returned value stores the mutable state</div><div><p></p></div><div>actor:</div><div>	a = Actor.new B.(x, y)</div><div>	a.do { b !B | ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>any definition whose name is the module's name, with the first letter capitalized,</div><div>	and possibly an additional number or extension (separated with an apostrophe),</div><div>	will be exported (ie is accessible outside of the module)</div><div>to access the definitions in a module which is inside a directory: dir.Definition</div><div>to hide a module so it can't be accessed from modules in the parent directory,</div><div>	append an apostrophe at the end of its file name</div><div>	this method can be used to make package private definitions too</div><div><p></p></div><div>a package is a collection of modules</div><div>in a project directory, we can have multiple package directories</div><div>	the name of the package directory is the package name, plus a ".jin" extension</div><div>packages are of two kinds:</div><div>, application packages that contain a file named "0.jina" (which must contain the init function)</div><div>, library packages</div><div><p></p></div><div>to use a library package in a another package, create a file named "your_chosen_name.p" with this format:</div><div>, first line is the name of the package</div><div>, second line is the URL of the project containing the package</div><div>, the format of the URL (where protocol can be gnunet, git):</div><div>	protocol://address'of'the'project'containing'package'directory</div><div>, the third line can contain a public key, which will be used to check the signature provided by the project</div><div>if there is no URL, it refers to the current project</div><div><p></p></div><div>to use the definitions of a package:</div><div>	dot'p'file'name.Definition</div><div>definitions in "std" package, are directly accessible</div><div>	there is no need for a "std.p" file, and prefixing with "std."</div><div><p></p></div><div>structs:</div><div>	S := a: A, b: B</div><div>defining methods (using a namespace):</div><div>	;ns S</div><div>		new = { a :A -&gt; S |</div><div>			b = ...</div><div>			a, b</div><div>		}</div><div>		m1 = { self!, x :X -&gt; Y |</div><div>			...</div><div>		}</div><div>		m2 = { self |</div><div>			...</div><div>		}</div><div>to create an instance of a struct:</div><div>	s :S = a: x, b: y</div><div>	s = S. a: x, b: y</div><div>	s = S.new a: x</div><div>accessing a member:</div><div>	s.a</div><div>calling a method (note that there is no record field named "m", otherwise this will not work):</div><div>	s.m x</div><div>which is equivalent to:</div><div>	S.m s x</div><div><p></p></div><div>unions:</div><div>	B := 'true \ 'false</div><div>type "A?" is a shortcut for "A\'null"</div><div>enumerate on a union:</div><div>	x :A? = 'null</div><div>	x @ {</div><div>	a :A |</div><div>		...</div><div>	:'null |</div><div>		...</div><div>	}</div><div><p></p></div><div>traits:</div><div>	;tr T</div><div>		m1 :(self: !T, x: X -&gt; Y)</div><div>		m2 = { self! |</div><div>			;; default implementation</div><div>		}</div><div>trait inheritance:</div><div>	;tr T : T1, T2</div><div>		...</div><div>defining the methods of a struct that implements some traits:</div><div>	;ns S</div><div>		m1 = ...</div><div>		m2 = ...</div><div>	;impl T1</div><div>		m3 = ...</div><div>		m4 = ...</div><div>	;impl T2</div><div>		...</div><div><p></p></div><div>generics:</div><div>	S[X] := a: X, b: X</div><div>bounded generics:</div><div>	S[X :I] := a: X, b: X</div><div><p></p></div><div>to directly enter C3 code:</div><div>	;c3 ...</div><div>		...</div><div>or:</div><div>	;c3</div><div>	...</div><div>	;</div><div>beware! with great power comes great responsibility</div></body></html>