
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Jina</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 2px;
      margin: 0;
      font-family: Hack;
      font-size: 11ppt;
      color: #222222;
      white-space: pre;
      tab-size: 4;
    }
  </style>
  </head><body><a href='https://github.com/damoonsaghian/Jina'><h1>Jina</h1></a>
<h2>1, Jina</h2><div>Jina is a programming language with sane memory management, actors, and a coherent type system and syntax</div><div><p></p></div><div>Mahsa Jina Amini was a 22 years old girl, murdered by the evil Islamic regime in Iran</div><div>at her funeral, these words were written on a stone above her grave:</div><div>	beloved Jina, you will not die, your name will become a code</div><div><p></p></div><div>Jina has sane memory management, ie there is no garbage collector</div><div>	<a href='https://www.toptal.com/software/eliminating-garbage-collector'>https://www.toptal.com/software/eliminating-garbage-collector</a></div><div>to achieve that, Jina introduces three special markers for types:</div><div>, unique type: T</div><div>, immutable shared type: T$</div><div>, immutable borrow type: T&</div><div>, mutable borrow type: T!</div><div><p></p></div><div>when a variable with unique type is aliased by another variable of the same unique type:</div><div>, if the original variable is not used in the following block (directly or through its borrowers),</div><div>	it's a shallow copy (heap part will not be copied)</div><div>, otherwise, it's a deep copy</div><div><p></p></div><div>variables with borrow types will be tagged by their owner</div><div>borrow tags will be inherited by further borrowers</div><div>function arguments with borrow type are tagged with integers, starting from zero</div><div>for functions with multiple borrow arguments, that also return a borrow type,</div><div>	and the scope tag of returned type is inherited from any borrow argument other than the first one (index 0),</div><div>	in the return type, it must be indicated that which borrow argument will the tag be inherited from</div><div>	A, B&, C& -&gt; C&2</div><div>the borrow tag of variables captured in a closure, will be prefixed with "PARENT_"</div><div>only borrows with matched tags can be assigned to each other (checked at compile'time)</div><div>this simple rule automatically guarantees correct lifetimes, cause it means:</div><div>, we can't assign a locally created (or moved) value, to a mutable borrow variable captured in a closure</div><div>, we can't return a borrow from a function, unless it's originally borrowed from one of the function's arguments</div><div><p></p></div><div>mutation of unique types, can only be seen by one variable</div><div>mutable borrow types allow shared mutation</div><div><p></p></div><div>dealing with allocated memory, at the end of functions:</div><div>, for unique types, if they are not moved out of the function, their heap memory will be deallocated</div><div>, for shared types, the reference count will be decreased by one, and when it reaches zero,</div><div>	their heap memory will be deallocated</div><div>, for borrow types, since they don't own the value, nothing happens</div><div><p></p></div><div>aliasing rules in variable definitions (and also assignments, in case of mutable ones, ie T and T!)</div><div>when a variable of type "T" is put into:</div><div>, a variable of type "T", shallow/deep copy</div><div>, a variable of type "T$", shallow/deep copy</div><div>, a variable of type "T&", shallow copy</div><div>, a variable of type "T!", copy address</div><div>when a variable of type "T$" is put into:</div><div>, a variable of type "T", deep copy</div><div>, a variable of type "T$", shallow copy, increase reference count</div><div>, a variable of type "T&", shallow copy</div><div>, a variable of type "T!", it's compile time error</div><div>when a variable of type "T&" is put into:</div><div>, a variable of type "T", deep copy</div><div>, a variable of type "T$", deep copy</div><div>, a variable of type "T&", shallow copy</div><div>, a variable of type "T!", it's compile time error</div><div>when a variable of type "T!" is put into:</div><div>, a variable of type "T", deep copy</div><div>, a variable of type "T$", deep copy</div><div>, a variable of type "T&", shallow copy</div><div>, a variable of type "T!", copy address</div><div><p></p></div><div>in Jina, type definitions containing borrow types, must have a borrow marker themselves:</div><div>	T& := A, B$, C&, D!</div><div>this is necessary for their scope tags to be statically determined</div><div>in other words, borrows can't be wrapped, they always leak out</div><div>so plain types (without borrow markers) can only contain unique and shared types:</div><div>	T := A, B$</div><div>of course, it can be aliased by variables with types that have markers:</div><div>	v :T$</div><div>		v.0 :A$</div><div>		v.1 :B$</div><div>	v :T&</div><div>		v.0 :A&</div><div>		v.1 :B&</div><div>	v :T!</div><div>		v.0 :A!</div><div>		v.1 :B&</div><div><p></p></div><div>in Jina, functions are closures, ie they can capture their environment</div><div>each function has its own distinct type that includes the type of the captured variables</div><div>but we usually do not work with function types directly</div><div>what we care about is the interface that a particular function implements</div><div>	f[t::(A,B-&gt;C)] :t& = { a :A, b :B -&gt; C | ... }</div><div>	f[t::(A,B-&gt;C)] :t = { a :A, b :B -&gt; C || ... }</div><div>a borrow closure (with type "t&") can have borrowed captured variables; an own closure (with type "t") can't</div><div><p></p></div><div>sharing mutable data in concurrent parts of a program is problematic</div><div>a data race happens when these three behaviors occur:</div><div>, two or more pointers access the same data at the same time</div><div>, at least one of the pointers is being used to write to the data</div><div>, there's no mechanism being used to synchronize access to the data</div><div>to deal with it, programming languages choose different approaches:</div><div>, some implement complicated and error prone lock mechanisms</div><div>, some abandon concurrency, and make single threaded programs</div><div>, functional programming languages avoid mutability as much as possible</div><div>	and when mutability is necessary, they use monads or algebraic effects to control shared mutability</div><div>	avoiding mutability, and the need for aggressive garbage collection, is not good for performance</div><div><p></p></div><div>Jina uses actors for asynchronous programming, and controls aliasing (sharing) and mutability using type markers,</div><div>	ie the same approach used to deal with memory management</div><div>messages sent to actors are own closures, and can't capture borrows</div><div>	their captured variables have either unique or shared (immutable) type</div><div>thus messages can safely be called concurrently, since they can't change their captured environment</div><div><p></p></div><div>actors are opaque types, ie their internal components are not accessible,</div><div>	and are referred to by an ID, instead of a memory address</div><div>actors (and their messages) can only be destroyed explicitly</div><div>reference counting combined with interior mutability can create reference cycles</div><div>	<a href='https://doc.rust-lang.org/book/ch15-06-reference-cycles.html'>https://doc.rust-lang.org/book/ch15-06-reference-cycles.html</a></div><div>	in Jina interior mutability is only possible using actors</div><div>	since actors are not reference counted, there is no reference cycles in Jina</div><div><p></p></div><div>types show us what we can do with the data, ie which operations are valid</div><div>subtyping is problematic:</div><div><a href='https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)'>https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)</a></div><div><a href='https://www.tedinski.com/2018/06/26/variance.html'>https://www.tedinski.com/2018/06/26/variance.html</a></div><div>i feel that this problem was the motivation behind dynamic typing (another bad design)</div><div>to avoid this problem, some languages (eg Rust) have two kinds of types:</div><div>, concrete types can be instantiated, but cannot have subtypes</div><div>, abstract types (also called traits or interfaces) cannot be instantiated, but can have subtypes</div><div>Rust has trait objects (dynamic interfaces) with the same problem regarding variance</div><div>	https://users.rust-lang.org/t/vector-covariant-in-its-element-type/80582</div><div>	https://stackoverflow.com/questions/55200843/what-does-it-mean-that-box-is-covariant-if-boxdyn-b-is-not-a-subtype-of-boxdy</div><div>in Jina we have interfaces, but there is no dynamic interfaces</div><div><p></p></div><div>instead, in Jina we have convertible types</div><div>it's like in mathematics where we can easily do arithmetic across integer, rational, real and complex numbers</div><div>when type "A" is convertible to type "B", it implements a special method named "into'B"</div><div>then when an expression of type "A" is used in a place that wants type "B",</div><div>	the compiler automatically inserts ".to'B"</div><div>the idea is to only do this for types that can be converted with negligible run'time overhead</div><div><p></p></div><div>Jina compiles to C3, and thus can easily use existing C libraries</div><div>C3 (unlike Rust) allows us to have packages that are compiled independently as dynamic libs,</div><div>	then imported and used in other packages</div><div><p></p></div><div>Jina is installed by default in SPM Linux</div><div>in other Unix'like systems:</div><div>, first install "spm", by following the instructions mentioned in SPM Linux project</div><div>, then run this:</div><div>	spm install $gnunet_namespace jina</div>
<h2>2, syntax</h2><div>comments:</div><div>	;; comment line</div><div>	;; comment</div><div>		block</div><div>	;;</div><div>	comment</div><div>	block</div><div>	;</div><div><p></p></div><div>identifiers (variable names) start with an alphabetic character, and can include numbers and apostrophe:</div><div>	abc'efg0123</div><div><p></p></div><div>defining a variable with unique type:</div><div>	v :T = ...</div><div>	v = ...</div><div>defining a variable with mutable borrow type:</div><div>	v :T! = ...</div><div>	v! = ...</div><div>defining a variable with immutable borrow type:</div><div>	v :T& = ...</div><div>	v& = ...</div><div>defining a variable with shared type:</div><div>	v :T$ = ...</div><div>	v$ = ...</div><div><p></p></div><div>assignment to mutable variables (ie those with unique or mutable'borrow type):</div><div>	v. = ...</div><div><p></p></div><div>numeric types types:</div><div>, Float: floating'point numbers with arbitrary precision and ball arithmetic</div><div>, Float2: floating'point numbers with double precision ("double" in C3)</div><div>, Float1: floating'point numbers with single precision ("float" in C3)</div><div>, Int: arbitrary sized integer</div><div>, Int8: 8 bytes integer ("long" in C3)</div><div>, Int4: 4 bytes integer ("int" in C3)</div><div>, Int2: 2 bytes integer ("short" in C3)</div><div>, Int1: 1 byte integer ("ichar" in C3)</div><div>, IntU: word'sized unsigned integer ("usz" in C3)</div><div>, IntU4: 4 bytes unsigned integer ("uint" in C3)</div><div>, IntU2: 2 bytes unsigned integer ("ushort" in C3)</div><div>, IntC: 1 byte unsigned integer ("char" in C3)</div><div>numeric literals:</div><div>	1.0 ;; Float2</div><div>	1.23e4</div><div>	0x1:0</div><div>	0x1:23p4</div><div>	1'234'567'890 ;; Int4</div><div>	0x1234'5678'9ABC'DEF0</div><div>	'a' ;; IntC, ASCII code for character "a"</div><div>	'\n' ;; ASCII code for character with escape code "\n"</div><div>	'\x12' ;; a byte with hexadecimal value 0x12</div><div>numbers are automatically converted when there is no data loss:</div><div>	i :Int8 = 123</div><div>	i = 123.to'Int8</div><div><p></p></div><div>complex numbers can be made of any type implementing the "Num" trait</div><div>	c :Complex[Int4] = 1 + 1i</div><div>	c = 1 + 0i</div><div>	c = Complex[Int4] 1 0</div><div><p></p></div><div>lists:</div><div>	l :List[IntC] = ['a', 'b', 'c']</div><div>indexing:</div><div>	e :Maybe[IntC] = l_1</div><div>note that the type of the result of indexing above is actually "Maybe[IntC]&",</div><div>	which is copied into the variable with type "Maybe[IntC]"</div><div>mutating lists:</div><div>	l.put 'd' at: 3 ;; ['a', 'b', 'c', 'd']</div><div>	l.put 'e' at: 0 ;; ['e', 'b', 'c', 'd']</div><div><p></p></div><div>character strings are UTF8 encoded, and implemented a list of characters:</div><div>	s :Str = "abc def"</div><div>string interpolation: "abc{x}"</div><div>alternative syntax that makes writing single word strings easier:</div><div>	'abc</div><div>multiline string equivalent to "first line\n\tsecond line":</div><div>	s = "</div><div>		first line</div><div>			second line</div><div>	"</div><div>it's better to split long strings into a list of single'line strings:</div><div>	s = """</div><div>		first line</div><div>			second line</div><div>	"""</div><div>which is equivalent to:</div><div>	["first line", "\tsecond line"]</div><div><p></p></div><div>dictionaries are indexed using strings (instead of "IntU" as in lists):</div><div>	d :Dict[Int4] = [a: 1, b: 2, c: 3]</div><div>indexing:</div><div>	d_'a</div><div><p></p></div><div>records:</div><div>	r :(Int4, Int4, c: Int4) = 1, 2, c: 3</div><div>to access elements:</div><div>	r.a</div><div>	r.0</div><div>multiple assignment using record expansion:</div><div>	a, b = 1, 2, 3</div><div>tagged fields can be expanded too, if the name of variables match:</div><div>	a, b = a: 1, b: 2</div><div>mutating a record field:</div><div>	r.a = 10</div><div>small records will be kept on stack, big ones on the heap</div><div><p></p></div><div>function:</div><div>	f = { a :A&, b :B! -&gt; C | ... }</div><div>note that the type of above function is:</div><div>	(a: A&, b: B! -&gt; C)&</div><div>function call:</div><div>	f x y</div><div>which is equivalent to these forms:</div><div>	f(x, y)</div><div>	f b: y a: x</div><div>	x, y &gt;&gt; f</div><div><p></p></div><div>default values for parameters:</div><div>	f = { a = 1 , b = 2 | ... }</div><div>	f b: 22</div><div>	f 11</div><div>	f()</div><div><p></p></div><div>conditional expression:</div><div>	condition .then {} .else {}</div><div>	condition1 .then {} .elif {condition2} {} .elif {condition3} {} .else {}</div><div><p></p></div><div>and or:</div><div>	a && b</div><div>	a \\ b</div><div>which are equivalent to:</div><div>	a .and {b}</div><div>	a .or {b}</div><div>not: -a</div><div><p></p></div><div>there is no loop construct directly available in Jina</div><div>instead we have iterators with "each" method, that is internally implemented using C3 loop</div><div>	iter.each { x | ... }</div><div>any type that implements "Iter" trait, must define an "iter" method,</div><div>	whose returned value stores the mutable state</div><div><p></p></div><div>actor:</div><div>	a :Actor[S] = Actor.new S.new()</div><div>	a.do { b :S! || ... }</div><div><p></p></div><div>modules are files containing definitions</div><div>any definition whose name is the module's name, will be exported (ie are accessible outside of the module)</div><div>exported names can have these kind of extensions:</div><div>, a number</div><div>, a word starting with capital letter</div><div>, letters inside brackets</div><div>to access the definitions in a module which is inside a directory: dir.Definition</div><div>to hide a module so it can't be accessed from modules in the parent directory, or outside of the package,</div><div>	append an apostrophe at the end of its file name</div><div><p></p></div><div>a package is a collection of modules</div><div>in a project directory, we can have multiple package directories</div><div>	the name of the package directory is the package name, plus a ".jin" extension</div><div>packages are of two kinds:</div><div>, application packages that contain a file named "0.jina" (which must contain the init function)</div><div>, library packages</div><div><p></p></div><div>to use a library package in a another package, create a file named "your'chosen'name.p" with this format:</div><div>, first line is the name of the package</div><div>, second line is the URL of the project containing the package</div><div>, the format of the URL (where protocol can be gnunet, git):</div><div>	protocol://address'of'the'project'containing'package'directory</div><div>, the third line can contain a public key, which will be used to check the signature provided by the project</div><div>if there is no URL, it refers to the current project</div><div><p></p></div><div>to use the definitions of a package:</div><div>	dot'p'file'name.Definition</div><div>definitions in "std" package, are directly accessible</div><div>	so there is no need for a "std.p" file, and prefixing with "std."</div><div><p></p></div><div>type definition:</div><div>	T := a: A, b: B</div><div>defining methods (using a namespace):</div><div>	;ns T</div><div>		new = { a :A -&gt; T |</div><div>			b = ...</div><div>			a, b</div><div>		}</div><div>		m1 = { self!, x :X -&gt; Y |</div><div>			...</div><div>		}</div><div>		m2 = { self |</div><div>			...</div><div>		}</div><div>to create an instance of the type:</div><div>	i :T = a: x, b: y</div><div>	i = T a: x, b: y</div><div>	i = T.new a: x</div><div>accessing a member:</div><div>	i.a</div><div>calling a method (note that there is no record field named "m", otherwise this will not work):</div><div>	i.m x</div><div>which is equivalent to:</div><div>	T.m i x</div><div>if a method has no argument (other than self), it can be called like this: i.m</div><div><p></p></div><div>enums:</div><div>	Bool := #true #false</div><div>	x :Bool = #true</div><div>	x = Bool#true</div><div>type "?A" is a shortcut for "Maybe[A]"</div><div>	Maybe[t] := #result t #null</div><div>	x :?A = #null</div><div>	x &gt;&gt; {</div><div>		#result x | ...</div><div>		#null | ...</div><div>	}</div><div><p></p></div><div>intefaces:</div><div>	;i I</div><div>		m1 ::(self!, x: X -&gt; Y)&</div><div>		m2 = { self! |</div><div>			;; default implementation</div><div>		}</div><div>interface inheritance:</div><div>	;i I ::I1 ::I2</div><div>		...</div><div>defining the methods of a type that implements some interfaces:</div><div>	;ns T ::I1 ::I2</div><div>		m1 = ...</div><div>		m2 = ...</div><div>		;; I1</div><div>		m3 = ...</div><div>		m4 = ...</div><div>		;; I2</div><div>		...</div><div><p></p></div><div>generics:</div><div>	T[g] := a: g, b: g</div><div>bounded generics:</div><div>	T[x::I] := a: x, b: x</div><div><p></p></div><div>to directly enter C3 code:</div><div>	;c3 ...</div><div>		...</div><div>or:</div><div>	;c3</div><div>	...</div><div>	;</div><div>declaring functions and types from a C3 lib</div><div>	;c3 extern fn ...;</div><div>	;c3 typedef ... = any;</div><div>beware! with great power comes great responsibility</div></body></html>