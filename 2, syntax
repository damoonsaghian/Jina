comments:
	;; comment line
	;; comment
		block
	;;
	comment
	block
	;

identifiers (variable names) start with an alphabetic character, and can include numbers and apostrophe:
	abc'efg0123
template identifiers ("x" and "y" can be used in the definition of the variable, where ever types are expected):
	abc[x,y]

variable definition:
	v :T = ...
	v = ...
mutable ref type variable definition:
	v :T! = ...
	v! = ...
immutable ref type variable definition:
	v :T& = ...
	v& = ...
shared reference variable definition:
	v :T$ = ...
	v$ = ...

assignment to mutable variables:
	v. = ...

numeric types:
, Num: floating point with mid-rad interval arithmetics (or C3 "double" if --no-flint)
, NumI: multi'precision integer (or C3 "isz" if --no-flint)
, NumW: word sized unsigned integers; compiled to "usz" type in C3
, Num8: compiled to "char" type in C3
literal numbers:
	1.23e4 ;; Num
	1.0 ;; Num
	1'234'567'890 ;; NumI
	0123 ;; NumW
	0x1234'5678'9abc'def0 ;; NumW (on 32 bits systems, this number will be stored as 0x9abc'def0)
	#a ;; Num8 (ASCII code for character "a")
	#\n ;; Num8 (ASCII code for character with escape code "\n")
	#x12 ;; Num8 (ASCII code for character with hex code 12)

lists:
	l :List[Num] = [1, 2, 3]
indexing:
	l_1
mutating lists:
	l.put 0 at: 0 ;; [0, 2, 3]
	l.put 4 at: 3 ;; [0, 2, 3, 4]
initial value of lists will be kept on stack

strings are UTF8 encoded, and implemented using lists:
	s :String = "abc def"
string interpolation: "abc{x}"
it's better to split long strings into a list of single'line strings:
	"""
	first line
		second line
	"""
which is equivalent to:
	["first line", "\tsecond line"]

symbols are their own types:
	s :'s = 's

dictionaries are indexed using strings (instead of integers as in lists):
	d :Dict[Num] = [a: 1, b: 2, c: 3]
indexing:
	d_"a"

lists and dictionaries can initially be stored on the stack, if they are small
then when they grow beyond its initial size, they will be reallocated on the heap

records:
	r :(a: Num, b: Num, c: Num) = a: 1, b: 2, c: 3
	r :(Num, Num, c: Num) = 1, 2, c: 3
to access elements:
	r.a
	r.0
multiple assignment using record expansion:
	a, b = 1, 2, 3
tagged fields can be expanded too, if the name of variables match:
	a, b = a: 1, b: 2
mutating a record (if "r" is a mutable variable):
	r.a = 10
small records will be kept on stack, big ones on the heap

function:
	f = { a :A, b &B -> C | ... }
note that the type of above function is:
	(a: A, b: &B -> C)
function call:
	f x y
which is equivalent to these forms:
	f(x, y)
	f b: y a: x
	(x, y) @ f

default values for parameters:
	f = { a = 1 , b = 2 | ... }
	f b: 22
	f 11
	f()

{f x y} can be written as: || f x y

conditional expression:
	condition.then {} else: {}
	condition1.then {} || condition2.then {} || condition3.then {} else: {}

and or:
	a && b
	a \\ b
which are equivalent to:
	a.and {b}
	a.or {b}
not: -a

there is no loop; just iterators:
	iter.each { x | ... }
any type that implements "Iter" interface, must define an "iter" method,
	whose returned value stores the mutable state

actor:
	a = Actor.new B.(x, y)
	a.do { b !B | ... }

modules are files containing definitions
any definition whose name is the module's name, will be exported (ie are accessible outside of the module)
exported names can have these kind of extensions:
, a number
, a word starting with capital letter
, letters inside brackets
to access the definitions in a module which is inside a directory: dir.Definition
to hide a module so it can't be accessed from modules in the parent directory, or outside of the package,
	append an apostrophe at the end of its file name

a package is a collection of modules
in a project directory, we can have multiple package directories
	the name of the package directory is the package name, plus a ".jin" extension
packages are of two kinds:
, application packages that contain a file named "0.jina" (which must contain the init function)
, library packages

to use a library package in a another package, create a file named "your'chosen'name.p" with this format:
, first line is the name of the package
, second line is the URL of the project containing the package
, the format of the URL (where protocol can be gnunet, git):
	protocol://address'of'the'project'containing'package'directory
, the third line can contain a public key, which will be used to check the signature provided by the project
if there is no URL, it refers to the current project

to use the definitions of a package:
	dot'p'file'name.Definition
definitions in "std" package, are directly accessible
	so there is no need for a "std.p" file, and prefixing with "std."

structs:
	S := a: A, b: B
defining methods (using a namespace):
	;ns S
		new = { a :A -> S |
			b = ...
			a, b
		}
		m1 = { self!, x :X -> Y |
			...
		}
		m2 = { self |
			...
		}
to create an instance of a struct:
	s :S = a: x, b: y
	s = S. a: x, b: y
	s = S.new a: x
accessing a member:
	s.a
calling a method (note that there is no record field named "m", otherwise this will not work):
	s.m x
which is equivalent to:
	S.m s x

unions:
	B := 'true \ 'false
type "?A" is a shortcut for "A\'null"
enumerate on a union:
	x :?A = 'null
	x @ { x :A |
		...
	x :'null |
		...
	}

traits:
	;tr T
		m1 :(self: !T, x: X -> Y)
		m2 = { self! |
			;; default implementation
		}
trait inheritance:
	;tr T : T1, T2
		...
defining the methods of a struct that implements some traits:
	;ns S
		m1 = ...
		m2 = ...
	;impl T1
		m3 = ...
		m4 = ...
	;impl T2
		...

generics:
	S[x] := a: x, b: x
bounded generics:
	S[x:I] := a: x, b: x

to directly enter C3 code:
	;c3 ...
		...
or:
	;c3
	...
	;
beware! with great power comes great responsibility
