comments:
	;; comment line
	;; comment
		block
	;;
	comment
	block
	;

identifiers (variable names) start with an alphabetic character, and can include numbers and apostrophe:
	abc'efg0123
template identifiers ("x" and "y" will be used in the definition of the variable):
	abc[x, y]

unique own variable definition:
	v :T = ...
immutable own variable definition:
	v :#T = ...
	v #T = ...
mutable own variable definition:
	v :!T = ...
	v !T = ...
immutable borrow variable definition:
	v :&T = ...
	v &T = ...
mutable borrow variable definition:
	v :$T = ...
	v $T = ...
assignment to mutable variables:
	v = ...

numeric types:
, Num: floating point with mid-rad interval arithmetics (or C3 "double" if --no-flint)
, Num'i: multi'precision integer (or C3 "isz" if --no-flint)
, Num'w: word sized unsigned integers; compiled to "usz" type in C3
, Num8: compiled to "char" type in C3
literal numbers:
	1'234'567'890 ;; Num (by default), can be Num'i, or Num'w too
	1.23e4 ;; Num
	123' ;; Num'i
	0x1234'5678'9abc'def0 ;; Num'w (on 32 bits systems, this number will be stored as 0x9abc'def0)
	0x ;; Num8 (ASCII code for character "a")
	0'SP ;; Num8 (ASCII code for control character "SP")

lists:
	l :List[Num] = [1, 2, 3]
indexing:
	l_1
negative indices count from the end of the list
mutating lists:
	l.put 0 index: 0 ;; [0, 2, 3]
	l.put 4 index: 3 ;; [0, 2, 3, 4]
initial value of lists will be kept on stack
heap allocation will be used only when the lists needs to grow beyond its initial size

strings are UTF8 encoded, and implemented using lists:
	s :String = "abc def"
one word string:
	'abc
string interpolation: "abc{x}"
it's better to split long strings into a list of single'line strings:
	""
	first line
		second line
	""
which is equivalent to:
	["first line", "\tsecond line"]

dictionaries are indexed using strings (instead of integers as in lists):
	d :Dict[Num] = ["a": 1, "b": 2, "c": 3]
when keys are one word strings, this can also be written as:
	[a: 1, b: 2, c: 3]
indexing:
	d_'a

records:
	r :(a: Num, b: Num, c: Num) = a: 1, b: 2, c: 3
	r :(Num, Num, c: Num) = 1, 2, c: 3
to access an element:
	r.a
	r.0
multiple assignment using record expansion:
	a, b = 1, 2, 3
tagged fields can be expanded too, if the name of variables match:
	a, b = a: 1, b: 2
mutating a record (if "r" is a mutable variable):
	r.a = 10

function:
	f :{a: A, b: !B -> C} = { a, b | ... }
function call:
	f x y
which is equivalent to these forms:
	f(x, y)
	f b: y a: x

default values for parameters:
	f = { a = 1 , b = 2 | ... }
	f b: 22
	f 11
	f()

conditional expression:
	condition.then {} .else {}
	condition1.then {} .elif condition2 {} .elif condition3 {} .else {}

and or:
	a && b
	a || b
which are equivalent to:
	a.and {b}
	a.or {b}
not: -a

there is no loop; just iterators:
	iter.each { x | ... }
any type that implements "Iter" interface, must define an "iter" method,
	whose returned value stores the mutable state
iterators store all states in their internal memory, so no memory allocation is done in the loop

actor:
	a = Actor B(x, y)
	a.do { b !B | ... }

modules are files containing definitions
any definition whose name is the module's name, with the first letter capitalized,
	and possibly an additional number or extension (separated with an apostrophe),
	will be exported (ie is accessible outside of the module)
to hide a definition, append an apostrophe at the end of its name: a' = ...
to access the definitions in a module which is inside a directory: dir.Definition
to hide a module so it can't be accessed from modules in the parent directory,
	append an apostrophe at the end of its file name

a package is a collection of modules
in a project directory, we can have multiple package directories
	the name of the package directory is the package name, plus a ".jin" extension
packages are of two kinds:
, application packages that contain a file named "0.jina" (which must contain the init function)
, library packages

to use a library package in a another package, create a file named "your_chosen_name.p" with this format:
, first line is the name of the package
, second line is the URL of the project containing the package
, the format of the URL (where protocol can be gnunet, git):
	protocol://address'of'the'project'containing'package'directory
, the third line can contain a public key, which will be used to check the signature provided by the project
if there is no URL, it refers to the current project

to use the definitions of a package:
	dot'p'file'name.Definition
definitions in "std" package, are directly accessible
	there is no need for a "std.p" file, and prefixing with "std."

structs:
	S := a: A, b: B
defining methods (using a namespace):
	;ns S
		new = { a :A -> S |
			b = ...
			a, b
		}
		m1 = { self, x :X -> Y |
			...
		}
		m2 = { self! |
			...
		}
to create an instance of a struct:
	s :S = a: x, b: y
	s :S = S.new a: x
accessing a member:
	s.a
calling a method (note that there is no record field named "m", otherwise this will not work):
	s.m x
which is equivalent to:
	S.m s x

singletons:
	B0 := () ;; false
	B0 :B0 = ()
	B1 := () ;; true
	B1 :B1 = ()
unions:
	B := B0 \ B1
type "A?" is a shortcut for "A\()"
match on a union:
	x :A? = ()
	x.match { a :A |
		...
	} .match { () |
		...
	}

traits:
	;tr T
		m1 :{ self, x :X -> Y}
		m2 = { self! |
			;; default implementation
		}
trait inheritance:
	;tr T : T1, T2
		...
defining the methods of a struct that implements some traits:
	;ns S
		m1 = ...
		m2 = ...
	;impl T1
		m3 = ...
		m4 = ...
	;impl T2
		...

generics:
	S[X] := a: X, b: X
bounded generics:
	S[X :I] := a: X, b: X

to directly enter C3 code:
	;c3 ...
		...
beware! with great power comes great responsibility
