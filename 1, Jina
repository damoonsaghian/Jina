Jina is a programming language with sane memory management, actors, and a coherent syntax

Mahsa Jina Amini was a 22 years old girl, murdered by the evil Islamic regime in Iran
at her funeral, these words were written on a stone above her grave:
	beloved Jina, you will not die, your name will become a code

memory management is done in a sane way, using container types:
, unique own: !!T
, mutable borrow: !T
, immutable ref type: T
, shared own: $T

at the end of the function:
, for unique own values, if not moved, the memory will be deallocated
, for shared own values, the atomic reference count will be decremented

borrows have an associated function
this associated function will be transferred to child borrows
borrows can't leave their associated function
for stack types (like numbers) the associated function is the global static space

unique own can be put into:
, unique own (move)
, mutable borrow (borrow)
, immutable borrow (copy stack, borrow heap)
, shared own (move)
and by "put into" i mean:
, variable assignment
, field assignment
, captured in a closure

mutable borrow can be put into:
, mutable borrow (borrow)
, immutable borrow (copy stack, borrow heap)

immutable borrow can be put into:
, immutable borrow (copy stack, borrow heap)

shared own can be put into:
, immutable borrow (copy stack, borrow heap)
, shared own (copy stack, borrow heap)
	increments the reference counter

in Jina, shared mutability is only possible through unique own types
thus reference cycles are impossible
"https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"

numbers are stored on the stack (thus don't need memory management)
small records will be kept on stack, big ones on the heap
lists and dictionaries can initially be stored on the stack, if they are small
	and when they grow they will be reallocated on the heap

"https://www.toptal.com/software/eliminating-garbage-collector"
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"

actors are used to achieve lock'free concurrency
sharing mutable data in concurrent parts of a program is problematic
a data race happens when these three behaviors occur:
, two or more pointers access the same data at the same time
, at least one of the pointers is being used to write to the data
, there's no mechanism being used to synchronize access to the data

to deal with it, programming languages choose different approaches:
, abandon concurrency altogether; make single threaded programs
, implement complicated and error prone lock mechanisms
, abandon mutability like in pure functional programming; but since at the end, mutability is necessary,
	a complicated mechanism like monads, linear types, effects, or Clojure reference types, must be used
	"https://stackoverflow.com/questions/9132346/clojure-differences-between-ref-var-agent-atom-with-examples"
	"https://clojure-doc.org/articles/language/concurrency_and_parallelism/"
	any how, the lack of direct mutability, and the need for aggressive garbage collection,
		means that functional programming is not an efficient method
, use the approach taken by Pony "https://www.ponylang.io/"
	it controls aliasing (sharing) and mutability, using reference capabilities
	Pony's approach introduces many complexities, especially when dealing with generics

in Jina, all mutations are done inside actors and are thus are synchronous
messages sent to actors are shared own closures
and as described above, they can only capture unique own and shared own variables
thus messages can safely be called asynchronously, since they can't change their captured environment

types show us what we can do with the data, ie which operations are valid
inheritance is problematic:
"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)"
"https://www.tedinski.com/2018/06/26/variance.html"
i feel that this problem was the motivation behind dynamic typing (another bad design)
to avoid this problem, some languages (eg Rust) have two kinds of types:
, concrete types can be instantiated, but cannot have subtypes
, abstract types cannot be instantiated, but can have subtypes
Jina does the same, without actually splitting types into two kinds

Jina compiles to C3, and thus can easily use existing C libraries

to install Jina in SPM Linux:
; spm install $gnunet_namespace jina
in other Unix'like systems, install "gnunet", then:
; gnunet-download -o spm/ gnunet://fs/sks/$gnunet_namespace/packages/spm
; sh spm/install.sh
; spm install $gnunet_namespace jina
